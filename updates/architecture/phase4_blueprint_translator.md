# Phase 4: Blueprint Translator — Architecture

## Overview

The translator is Stage 4 of the paper-to-blueprint pipeline. It takes a
`ComprehensionSummary` (Stage 1) + `ClassificationResult` (Stage 2) and
produces an ADR-005 WU-defined `Blueprint` using agent-factors DAG models.
The translation is fully rule-based per innovation type — no LLM calls.

## Pipeline Flow

```
ComprehensionSummary ─┐
                      │
ClassificationResult ─┼──→ translate(TranslationInput)
                      │          │
    manifests_dir ────┘          ├─ 1. identify_targets() ──→ FileTargeting
    ledger_path ─────────────────├─ 2. mine_ledger() ──→ ChangePatternReport
                                 ├─ 3. decompose() ──→ list[WorkingUnit]
                                 ├─ 4. Build Phase + BlueprintMetadata
                                 ├─ 5. Build DeferredItems
                                 ├─ 6. Assemble Blueprint
                                 ├─ 7. validate_dag() ──→ DAGValidationReport
                                 └─ 8. Compute test estimates
                                          │
                                 TranslationResult
                                 (blueprint, validation_report,
                                  file_targeting, change_patterns,
                                  test_estimate_low, test_estimate_high)
                                          │
                              serialize_blueprint() ──→ ADR-005 markdown
                              write_blueprint() ──→ file on disk
```

## WU Decomposition Templates

Each innovation type has a dedicated template producing WUs within bounded ranges:

| Type | WU Range | Template Structure |
|------|----------|--------------------|
| `parameter_tuning` | 1-3 | Identify param → Apply + validate → Regression boundary |
| `modular_swap` | 3-5 | Study interface → Implement replacement → (Adapter) → Integration → Regression |
| `pipeline_restructuring` | 5-12 | Analyze topology → Design new → Per-stage WUs (≤6) → Contracts → Integration → Regression |
| `architectural_innovation` | 8-20 | Define interfaces → Scaffold → Per-primitive WUs (≤8) → Integration layer → Pipeline → Tests → E2E → Docs |

WU count is optionally nudged by historical ledger data (30% weight) via `_adjust_wu_count()`.

## Manifest Targeting

Scans clearinghouse YAML manifests (`functions[].name/docstring/module_path`,
`classes[]`) for case-insensitive substring matches against:
- `summary.paper_terms`
- `summary.inputs_required`
- `summary.outputs_produced`

Matched `source_file` entries → `files_modified`. Innovation-type-specific
`files_created` generated by template (e.g., parameter_tuning creates nothing,
architectural creates primitive + integration + test files).

## Historical Change Patterns

`mine_ledger()` reads the clearinghouse JSONL ledger:
1. Counts entries with `blueprint_ref`
2. Groups by `meta_category` and inferred innovation type
3. Computes `avg_wu_count`, `avg_test_ratio`, `common_phase_count`
4. Falls back to `DEFAULT_PATTERN_STATS` when < 3 entries have `blueprint_ref`

Default stats:
```
parameter_tuning:        avg_wu=2.0, test_ratio=4.0
modular_swap:            avg_wu=4.0, test_ratio=3.5
pipeline_restructuring:  avg_wu=8.0, test_ratio=3.0
architectural_innovation: avg_wu=14.0, test_ratio=2.5
```

## Deferred Item Rules

`DeferredItem`s (RE-D{N}) generated when:
- `pipeline_restructuring`/`architectural_innovation` with multi-repo targeting
- Limitations containing "model", "requires", "not currently"

## ADR-005 Serialization

Output format is Tier 1 (compact table) markdown:
- Title heading, metadata block (Date, Status, Meta-category)
- Phase section with WU table (Working Unit | Description | Depends On | Acceptance Criteria)
- Deferred Items table
- Round-trip verified: `serialize_blueprint()` → `parse_blueprint()` → `validate_dag()` passes

## agent-factors Integration

| What | Import | Usage |
|------|--------|-------|
| `Blueprint`, `Phase`, `WorkingUnit` | `agent_factors.dag.schema` | Blueprint assembly |
| `BlueprintMetadata`, `BlueprintStatus` | `agent_factors.dag.schema` | Metadata with planned status |
| `DeferredItem` | `agent_factors.dag.schema` | Limitation-derived deferrals |
| `validate_dag`, `DAGValidationReport` | `agent_factors.dag.validator` | Structural DAG validation |
| `parse_blueprint` | `agent_factors.dag.parser` | Round-trip verification |

## Module Layout

```
research_engineer/translator/
├── __init__.py              # Public exports (14 symbols)
├── manifest_targeter.py     # FileTarget, FileTargeting, identify_targets()
├── change_patterns.py       # ChangePatternStats, ChangePatternReport, mine_ledger()
├── wu_decomposer.py         # DecompositionConfig, decompose(), validate_decomposition()
├── translator.py            # TranslationInput, TranslationResult, translate()
└── serializer.py            # serialize_blueprint(), write_blueprint()

scripts/
└── evaluate_paper.py        # CLI: --translate --input --output-dir --manifests-dir --ledger
```

## Key Invariants

1. Translation is **deterministic** — same inputs always produce same Blueprint
2. All generated Blueprints **pass validate_dag()** (acyclicity, completeness, reachability, numbering)
3. WU counts are **bounded** by innovation type ranges
4. Serialized markdown **round-trips** through parse_blueprint() + validate_dag()
5. CLI is **backwards compatible** — `--classify-only` still works unchanged
